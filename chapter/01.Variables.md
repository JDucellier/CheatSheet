# Variables

## Declare Variables

### Simple Types

---

```typescript
//String
let name: string = "Jean";
//Number
let age: number;
//Boolean
let isAwesome: boolean;
//Two way to declare an Array
let listOfEvens: number[] = [2, 4, 6];
let listOfOdds: Array<number> = [1, 3, 5];

//Tuple (Let you create an fixed-length array mixed types)
let nameAgeArr: [string, number];
nameAgeArr = ["Jean", 666]; // no Error
nameAgeArr = [666, "Jean"];

//Enum
enum Genre {
  Rock,
  Jazz,
  Classic,
  Metal,
}
```

### Never

---

> Never type represent the type of values that never occur. For example, a function that always throws an error when called will never return, so we can set the return type to never. An infinite loop could also have the return type never.

```typescript
function throwError(msg: string): never {
  throw new Error(msg);
}
```

### Object

---

```typescript
let shane: object;
shane = { name: "Shane", age: 24 }; // ✅
shane = () => console.log("Hi, my name is Shane"); // ✅
shane = "Shane"; // ❌
```

### Union Types and Aliases

---

> If you variable or parameter needs to have more flexibility, you can specify multiple type options using union types.

```typescript
let numberOrString: number | string;
numberOrString = 13; // ✅
numberOrString = "thirteen"; // ✅
```

> You can also define your own types, known as aliases, which can be used as type definitions later.

```typescript
type FlexibleNumber = number | string;
let luckyNumber: flexibleNumber = 13;
luckyNumber = "thirteen"; // ✅
```

## Interface

```typescript
interface Album {
    name: string;
    artist: string;
    numSongs: number;
}

const sgtPepper: Album = {
    name: "Sgt. Pepper's Lonely Hearts Club Band",
    artist: "John Coltrane",
    numSongs: 13
    isGood: true // Allowed to have additional properties
}

const help: Album = {
    isGood: true // ❌, must contain all properties from interface
}
```
